public static byte[] rc4KeySchedule(byte[] key) {
    byte[] S = new byte[256];
    for (int i = 0; i < 256; i++) {
        S[i] = (byte) i;
    }
    int j = 0;
    for (int i = 0; i < 256; i++) {
        j = (j + S[i] + key[i % key.length]) & 0xFF;
        byte temp = S[i];
        S[i] = S[j];
        S[j] = temp;
    }
    return S;
}

public static byte[] rc4GenerateKeystream(byte[] S, int length) {
    byte[] keystream = new byte[length];
    byte[] T = S.clone();
    int i = 0, j = 0;
    for (int k = 0; k < length; k++) {
        i = (i + 1) & 0xFF;
        j = (j + T[i]) & 0xFF;
        byte temp = T[i];
        T[i] = T[j];
        T[j] = temp;
        keystream[k] = T[(T[i] + T[j]) & 0xFF];
    }
    return keystream;
}

public static byte[] rc4Encrypt(byte[] plaintext, byte[] key) {
    byte[] S = rc4KeySchedule(key);
    byte[] keystream = rc4GenerateKeystream(S, plaintext.length);
    byte[] ciphertext = new byte[plaintext.length];
    for (int i = 0; i < plaintext.length; i++) {
        ciphertext[i] = (byte) (plaintext[i] ^ keystream[i]);
    }
    return ciphertext;
}

public static int binaryDerivativeTest(byte[] data) {
    int count = 0;
    for (int i = 0; i < data.length - 1; i++) {
        if (((data[i] ^ data[i+1]) & 0x01) != 0) {
            count++;
        }
    }
    return count;
}
