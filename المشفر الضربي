
int find_gcd(int r1, int r2) {
    while (r2 > 0) {
        int q = r1 / r2;
        int r = r1 - (q * r2);
        r1 = r2;
        r2 = r;
    }
    return r1;
}

// Function 2: Modular Inverse
int inversing(int n, int k) {
    int t1 = 0, t2 = 1;
    int r1 = n, r2 = k;
    
    while (r2 > 0) {
        int q = r1 / r2;
        int r = r1 - (q * r2);
        r1 = r2;
        r2 = r;
        
        int t = t1 - (q * t2);
        t1 = t2;
        t2 = t;
    }
    
    if (r1 != 1) return -1;
    if (t1 < 0) t1 = n + t1;
    
    return t1;
}

// Function 3: Encryption
String encryption(char[] plainText, int k, int n) {
    String cipherText = "";
    for (int i = 0; i < plainText.length; i++) {
        int idx = plainText[i] - 'a';
        int cipher = (idx * k) % n;
        cipherText += (char)(cipher + 'A');
    }
    return cipherText;
}

// Function 4: Decryption
String decryption(char[] cipherText, int k, int n) {
    String plainText = "";
    int k_inv = inversing(n, k);
    
    if (k_inv == -1) return "Invalid key (no inverse)";
    
    for (int i = 0; i < cipherText.length; i++) {
        int idx = cipherText[i] - 'A';
        int p = (idx * k_inv) % n;
        plainText += (char)(p + 'a');
    }
    return plainText;
}
